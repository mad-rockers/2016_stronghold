// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "HarvesterLoop.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

HarvesterLoop::HarvesterLoop(int HarvesterState): Command() {
    m_HarvesterState = HarvesterState;
        // Use requires() here to declare subsystem dependencies
    // eg. requires(chassis);
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::harvester.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void HarvesterLoop::Initialize() {
	//enable the harvester pid
	HarvestP = Preferences::GetInstance()->GetDouble("Harvester P",20);

}

// Called repeatedly when this Command is scheduled to run
void HarvesterLoop::Execute() {
	struct timeval tv;
	gettimeofday(&tv,NULL);
	current_time = (double)((double)tv.tv_sec + ((double)tv.tv_usec)/1000000.0);


	//SmartDashboard::PutNumber("current_time",current_time);
	//SmartDashboard::PutNumber("ref_time",ref_time);
	//SmartDashboard::PutNumber("ref > current",ref_time>current_time);

	SmartDashboard::PutNumber("PID setpoint",Robot::harvester->GetSetpoint());
	SmartDashboard::PutNumber("PID position",Robot::harvester->GetPosition());
	SmartDashboard::PutNumber("PID motor output",RobotMap::harvesterHarvesterAngleMotor->Get());
	SmartDashboard::PutNumber("inlaunchposition",Robot::catapult->getlimit() );

	SmartDashboard::PutNumber("Harvester State",Robot::harvester->HarvesterState);
	SmartDashboard::PutNumber("ball input",Robot::harvester->ballSensor->Get());
	SmartDashboard::PutNumber("Harvest motor output",RobotMap::harvesterHarvesterFeedMotor->Get());


	if (SmartDashboard::GetBoolean("DB/Button 0",0)==0){
		//test mode
		Robot::harvester->Disable();
		if(Robot::oi->getxbox()->GetRawButton(8)){//up
			Robot::harvester->harvesterAngleMotor->Set(SmartDashboard::GetNumber("DB/Slider 0",0)/5);
		}
		else if(Robot::oi->getxbox()->GetRawButton(7)){//down
			Robot::harvester->harvesterAngleMotor->Set(SmartDashboard::GetNumber("DB/Slider 1",0)/(-5));
		}
		else {
			Robot::harvester->harvesterAngleMotor->Set(0);
		}
		if (Robot::harvester->HarvesterState == 0){ //feed state

			if (Robot::harvester->ballSensor->Get() == 0){
				if (ref_time > current_time){
					Robot::harvester->setHarvestMotor(Robot::oi->getxbox()->GetRawAxis(3));//positive is reverse
				}
				else {
					Robot::harvester->setHarvestMotor(-1*Robot::oi->getxbox()->GetRawAxis(3)); // negative is forward
					quickReverse = 0;
				}
			}
			else {
				if (quickReverse == 0){
					ref_time = (current_time + 1); // reverses the motor for 1 seconds while ball is not seen
					quickReverse = 1;
				}
				Robot::harvester->setHarvestMotor(0);
			}
		}
	}
	else{
		double Degree0 = .155;
		double Degree90 = .47;
		double theta = (Robot::harvester->GetPosition()-Degree0)/(Degree90-Degree0)*(3.14/4);//radians
		if (Robot::harvester->GetSetpoint()>Robot::harvester->GetPosition()){

			Robot::harvester->SetPID(HarvestP*cos(theta)+2,0,0);
		}
		else{
			Robot::harvester->SetPID(2,0,0);
		}
		Robot::harvester->Enable();
		//state machine
		if (Robot::harvester->HarvesterState == 0){ //feed state

			Robot::harvester->SetSetpoint(Degree0);//down

			if (Robot::harvester->ballSensor->Get() == 0){
				if (ref_time > current_time){
					Robot::harvester->setHarvestMotor(.05);//positive is reverse
				}
				else {
					Robot::harvester->setHarvestMotor(-.5); // negative is forward
					quickReverse = 0;
				}
			}
			else {
				if (quickReverse == 0){
					ref_time = (current_time + 1); // reverses the motor for 1 seconds while ball is not seen
					quickReverse = 1;
				}
			Robot::harvester->setHarvestMotor(0);
			}

		}
		else if (Robot::harvester->HarvesterState == 1){// low bar state

			Robot::harvester->SetSetpoint(.2);//10 degrees
			Robot::harvester->setHarvestMotor(0);
		}
		else if (Robot::harvester->HarvesterState == 2){//load catapult state

			Robot::harvester->SetSetpoint(Degree90);//90 degrees
			if (Robot::oi->getxbox()->GetRawButton(8)== 1){
				Robot::harvester->setHarvestMotor(-.1);
			}
			else {
				Robot::harvester->setHarvestMotor(0);
			}
		}
	}

	SmartDashboard::PutNumber("uplimit1",DigitalInput(8).Get());
	SmartDashboard::PutNumber("downlimit2",DigitalInput(9).Get());
	if (DigitalInput(8).Get()==0 && Robot::harvester->harvesterAngleMotor->Get() > 0){
		Robot::harvester->harvesterAngleMotor->Set(0);
	}
	if (DigitalInput(9).Get()==0 && Robot::harvester->harvesterAngleMotor->Get() < 0){
		Robot::harvester->harvesterAngleMotor->Set(0);
	}

}
// Make this return true when this Command no longer needs to run execute()
bool HarvesterLoop::IsFinished() {
    return true;
}

// Called once after isFinished returns true
void HarvesterLoop::End() {

}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void HarvesterLoop::Interrupted() {

}
