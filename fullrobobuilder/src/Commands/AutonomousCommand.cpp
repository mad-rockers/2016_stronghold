// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "AutonomousCommand.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

AutonomousCommand::AutonomousCommand(int AutonomousState): Command() {
    m_AutonomousState = AutonomousState;
        // Use requires() here to declare subsystem dependencies
    // eg. requires(chassis);
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::tankDriveTrain.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void AutonomousCommand::Initialize() {
	TimeToPassDefense[0] = 3.0;
	TimeToPassDefense[1] = 3.0;
	TimeToPassDefense[2] = 3.0;
	TimeToPassDefense[3] = 3.0;
	TimeToPassDefense[4] = 3.0;
	TimeToPassDefense[5] = 3.0;
	TimeToPassDefense[6] = 3.0;
	TimeToPassDefense[7] = 3.0;
	slot_forward_time[0] = 3.0;
	slot_forward_time[1] = 2.0;
	slot_forward_time[2] = 2.0;
	slot_forward_time[3] = 3.0;
	defense_motor_init[0] = 0.5;
	defense_motor_init[1] = 0.5;
	defense_motor_init[2] = 0.5;
	defense_motor_init[3] = 0.5;
	defense_motor_init[4] = 0.5;
	defense_motor_init[5] = 0.5;
	defense_motor_init[6] = 0.5;
	defense_motor_init[7] = 0.5;
	trackLightPixelBias[0] = 400;
	trackLightPixelBias[1] = 0;
	trackLightPixelBias[2] = 0;
	trackLightPixelBias[3] = 280;
	turnTowardsGoalTime[0] = 1.0;
	turnTowardsGoalTime[1] = 0;
	turnTowardsGoalTime[2] = 0;
	turnTowardsGoalTime[3] = 1.0;


	SmartDashboard::PutString("DB/String 0", "Defense");
	SmartDashboard::PutString("DB/String 1", "Lane");
	//SmartDashboard::PutString("DB/String 2", "Spybot");

	unsigned char mybuffer[32];
	switch (DriverStation::GetInstance().GetAlliance()) {
	    case DriverStation::kRed:
	    	SmartDashboard::PutString("Alliance", "red");
	    	mybuffer[0] = 0xAA; //alliance header red
	        // red
	        break;
	    case DriverStation::kBlue:
	    	mybuffer[0] = 0xAB; //alliance header blue
	    	SmartDashboard::PutString("Alliance", "blue");
	        // blue
	        break;
	    case DriverStation::kInvalid:
	    default:
	        // unknown
	        break;

	}
	Robot::myNetwork->SendPCDFront( mybuffer, 3 ); //send alliance color to the pcduino

	// setup the builtInAccel accel to use 2 g's
	Accel.SetRange( Accelerometer::kRange_2G );

	autoState = moveForwardOverDefense;

	// read all of the switches once
	defenseType = (DefenseType)(Preferences::GetInstance()->GetInt("Defense",0));
	slotLocation = Preferences::GetInstance()->GetInt("Lane",0);
	//SmartDashboard::PutNumber("defenseInput",defenseType);
	//SmartDashboard::PutNumber("slot",slotLocation);

	// set the drive motors to 80%
	Robot::tankDriveTrain->arcade( defense_motor_init[(int)defenseType], 0.0 ); // yaw, forward

	// send the PCD a command to start sending track information for the goal
	unsigned char buff[COMMAND_MESSAGE_SIZE];
	buff[0] = TURN_ON_VERT_LIGHTS_AIDING;
	Robot::myNetwork->PCD_front.send( buff, 1 ); // ???? do I send light commands on the goal network

	// send the PCD a command to start sending track information for the goal

	buff[0] = TURN_OFF_GOAL_AIDING;
	Robot::myNetwork->PCD_front.send( buff, 1 );

	// send the PCD a command to start sending track information for the goal
	buff[0] = TURN_OFF_BALL_AIDING;
	Robot::myNetwork->PCD_back.send( buff, 1 );


	MAX_ROW_TO_SHOOT = Preferences::GetInstance()->GetInt( "MaxImgRow", 100 );
	MIN_ROW_TO_SHOOT = Preferences::GetInstance()->GetInt( "MinImgRow", 100 );
	// get the time of day for a start auto reference
	struct timeval tv;
	gettimeofday( &tv, NULL );
	ref_time = (double)((double)tv.tv_sec + ((double)tv.tv_usec)/1000000.0);
}

// Called repeatedly when this Command is scheduled to run
void AutonomousCommand::Execute() {

	// drain the messages from the PCD
	int len_goal_msg, len_lights_msg;
	unsigned char buffer[16];

	struct message_str incoming_data;
	struct timeval tv;

	len_goal_msg = Robot::myNetwork->PCD_front.receive( buffer );
	if( len_goal_msg > 0 )
	{
		memcpy( &incoming_data, buffer, COMMAND_MESSAGE_SIZE );
		if( incoming_data.header == GOAL_INCOMING_COMMAND ) {
			current_goal_error = incoming_data.error;
			current_goal_row = incoming_data.row;
		}
	}
	else {
		current_goal_error = 0; // pixels
		current_goal_row = 0;
	}

	// check for a PCD lights message
	len_lights_msg = Robot::myNetwork->PCD_front.receive( buffer );
	if( len_lights_msg > 0 )
	{
		memcpy( &incoming_data, buffer, COMMAND_MESSAGE_SIZE );
		if( incoming_data.header == LIGHTS_INCOMING_COMMAND )
			current_lights_error = incoming_data.error;
	}
	else
		current_lights_error = 0; // pixels

	// user the current_error to bias in one direction

	gettimeofday( &tv, NULL );
	double current_time = (double)((double)tv.tv_sec + ((double)tv.tv_usec)/1000000.0) - ref_time;

	if( autoState == moveForwardOverDefense )//TODO: add a default command if no smart dashboard connection
	{
		if( defenseType == PORTCULLIS ) {
			if( current_time < 1.5 ) {
				// lower the arm into place

			}
			else if( ( current_time >= 1.5 ) && ( current_time < 2.5 ) ) {
				// raise up the arm

			}
			else{
				// stop the arm
			}

		}
		else if( defenseType == CHEVAL_DE_FRISE ) {
			// lower the arm to bring down the ramps
			if( current_time < 2.0 ){

			}
			else{

			}

		}

		else if( defenseType == SALLY_PORT ) {
			// the sally port has to be opened from towards the center of the court
			// good luck!!
		}
		else if( defenseType == DRAW_BRIDGE ) {
			// the draw bridge has to be opened from towards the center of the court
			// good luck!!
		}
		else if( defenseType == ROCK_WALL ) {
			Robot::tankDriveTrain->arcade(0.5, 0.0);
		}
		else if( defenseType == ROUGH_TERRAIN ) {
			Robot::tankDriveTrain->arcade(0.5, 0.0);
		}
		else if( defenseType == RAMPART ) {
			Robot::tankDriveTrain->arcade(0.5, 0.0);
		}
		else if( defenseType == MOAT ) {
			Robot::tankDriveTrain->arcade(0.5, 0.0);
		}

		// only start looking at accel if it has been N seconds
		if( current_time > TimeToPassDefense[defenseType] )
		{
			// start tracking when the chassis is over the defense
			// get 10 good samples to make sure we are level
			double accelz = Accel.GetZ(); //

			if( accelz > 0.8 )
			{
				accel_cnt ++;
				if( accel_cnt > 10 ) {
					autoState = trackLights;
					startTrackLightsTime = current_time;
				}
			}
		}
	}
	else if( autoState == trackLights )
	{
		int error_pixels;
		// use proportional gain to turn
		int delta_pixels = trackLightPixelBias[slotLocation] - current_lights_error;
		if( abs(delta_pixels) > 20 ) { // pixels
			// bias theta is -20 deg or about 500 pixels.
			error_pixels = delta_pixels;
		}
		else
			error_pixels = 0;

		// stay in one location and change heading to bias to final location
		if( error_pixels < 20 ) // pixels
		{
			autoState = moveForwardToShoot; //  ???? I could track the yellow lights to find range to stop
			unsigned char buff[5];
			buff[0] = TURN_OFF_VERT_LIGHTS_AIDING;
			Robot::myNetwork->PCD_front.send( buff, 1 );

			buff[0] = TURN_ON_GOAL_AIDING;
			Robot::myNetwork->PCD_front.send( buff, 1 );

			moveForwardToShootRefTime = current_time;
		}
		else {
			if( error_pixels < 0 ) {
				Robot::tankDriveTrain->CameraPID(error_pixels);
			}
		}

		// do not wait too long to find the lights and turn
		if( (current_time-startTrackLightsTime) > 3.0 )
		{
			autoState = moveForwardToShoot;
		}
	}
	else if( autoState == moveForwardToShoot )
	{
		Robot::tankDriveTrain->arcade( 0.8, 0.0 ); // ???? but is the robot going straight enough?
		if( (current_time-moveForwardToShootRefTime) > slot_forward_time[slotLocation] ) {
			Robot::tankDriveTrain->arcade( 0.0, 0.0);
			autoState = turnTowardsGoal;
			timeInTurnTowardsGoal = current_time;
		}
	}
	else if( autoState == turnTowardsGoal )
	{
		if( turnTowardsGoalTime[slotLocation] < 0 ) //double check with tim
			Robot::tankDriveTrain->CameraPID(100);
		if( (turnTowardsGoalTime[slotLocation] - current_time ) > timeInTurnTowardsGoal )
			Robot::tankDriveTrain->arcade(0.0, 0.0);

		autoState = trackGoals;
	}
	else if( autoState == trackGoals )
	{
		// move up a little
		/*if( current_goal_row != 0 ) {
			if( current_goal_row < Robot::myCamera->MAX_ROW_TO_SHOOT ) // too far
				Robot::drivetrain->arcade( 0.30, 0.0 ,0.0);
			else if( current_goal_row > Robot::myCamera->MIN_ROW_TO_SHOOT ) // too close
				Robot::drivetrain->arcade( -0.30, 0.0, 0.0 );
			else
				Robot::drivetrain->arcade( 0.0, 0.0, 0.0 );
		}
		*/
		if( current_goal_row != 0 ) {
			if( current_goal_row < MAX_ROW_TO_SHOOT ) // too far
				Robot::tankDriveTrain->arcade( 0.30, 0.0);
			else if( current_goal_row > MIN_ROW_TO_SHOOT ) // too close
				Robot::tankDriveTrain->arcade( -0.30, 0. );
			else
				Robot::tankDriveTrain->arcade( 0.0, 0.0);
		}
		else
			Robot::tankDriveTrain->arcade( 0.0, 0.0 );


		// slow down as a function of time past track mode
		// go ahead and stop if it has been too long tracking
		if( ( current_time - startTrackGoalTime ) > 3.0 ) {
			autoState = stop;
		}

		// the target is contained at the correct row for range
		//if( ( incoming_data.row < Robot::myCamera->MAX_ROW_TO_SHOOT ) && ( incoming_data.row > Robot::myCamera->MIN_ROW_TO_SHOOT ) ) {
		//	autoState = stop;
		//}
		// the target is contained at the correct row for range
		if( ( incoming_data.row < MAX_ROW_TO_SHOOT ) && ( incoming_data.row > MIN_ROW_TO_SHOOT ) ) {
			autoState = stop;
		}

	}
	else if( autoState == stop )
	{
		// change heading until the track command reaches deadband
		if( abs(current_goal_error) > DEADBAND ) {
			Robot::tankDriveTrain->CameraPID( current_goal_error );
		}
		else
		{
			Robot::tankDriveTrain->CameraPID(0.0);
			autoState = shoot;
		}

		// the auto time will expire in 15 so rush the shot if we need to
		if( (current_time-ref_time) > (MAX_AUTO_TIME-1.0) ) // we need time for the ball to make it.
		{
			autoState = shoot;
			unsigned char buff[5];
			buff[0] = TURN_OFF_GOAL_AIDING;
			Robot::myNetwork->PCD_front.send( buff, 1 );
		}
	}
	else if( autoState == shoot )
	{
		// do I need to release the safety?

		DigitalInput loaded(1); //limit switch indicating the launcher is in the loaded position

		if (loaded.Get()== 1){

		}

		//shooter.Set(1.0); // launch ball

		// turn off shooter in teleopInit() or here????
	}
}

// Make this return true when this Command no longer needs to run execute()
bool AutonomousCommand::IsFinished() {
    return false;
}

// Called once after isFinished returns true
void AutonomousCommand::End() {

}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void AutonomousCommand::Interrupted() {

}
